CCS PCM C Compiler, Version 5.007, 61971               09-Tem-23 18:19

               Filename:   C:\Users\berki\Desktop\Mikro Projeler\Parking Control System\3_LCD_SAYAC\lcdyazi.lst

               ROM used:   564 words (7%)
                           Largest free fragment is 2048
               RAM used:   10 (3%) at main() level
                           25 (7%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   1C6
0003:  NOP
.................... #include <16f877.h>                 // Kullanýlacak pic headerý çaðrýlýyor 
.................... //////// Standard Header file for the PIC16F877 device //////////////// 
.................... #device PIC16F877 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  28
0009:  RETLW  0C
000A:  RETLW  01
000B:  RETLW  06
000C:  DATA 0C,10
000D:  DATA 41,39
000E:  DATA E1,31
000F:  DATA A0,29
0010:  DATA E1,3C
0011:  DATA E9,39
0012:  DATA 69,10
0013:  DATA 25,32
0014:  DATA 00,00
0015:  DATA 8C,20
0016:  DATA F2,30
0017:  DATA 63,10
0018:  DATA E7,34
0019:  DATA F2,32
001A:  DATA ED,32
001B:  DATA 7A,17
001C:  DATA A0,12
001D:  DATA 64,00
001E:  DATA 8C,20
001F:  DATA F2,30
0020:  DATA 63,10
0021:  DATA F3,30
0022:  DATA F9,34
0023:  DATA F3,34
0024:  DATA A0,12
0025:  DATA 64,00
0026:  DATA 8C,20
0027:  DATA F2,30
0028:  DATA 63,10
0029:  DATA D3,30
002A:  DATA F9,34
002B:  DATA F3,34
002C:  DATA A0,12
002D:  DATA 64,00
*
0106:  MOVF   0B,W
0107:  MOVWF  25
0108:  BCF    0B.7
0109:  BSF    03.5
010A:  BSF    03.6
010B:  BSF    0C.7
010C:  BSF    0C.0
010D:  NOP
010E:  NOP
010F:  BTFSC  03.0
0110:  GOTO   138
0111:  BCF    03.5
0112:  MOVF   0C,W
0113:  ANDLW  7F
0114:  BCF    03.6
0115:  MOVWF  26
0116:  BSF    03.6
0117:  MOVF   0D,W
0118:  BCF    03.6
0119:  MOVWF  27
011A:  BSF    03.6
011B:  MOVF   0F,W
011C:  BCF    03.6
011D:  MOVWF  28
011E:  MOVF   26,W
011F:  MOVWF  2A
0120:  CALL   0DA
0121:  MOVF   27,W
0122:  BSF    03.6
0123:  MOVWF  0D
0124:  BCF    03.6
0125:  MOVF   28,W
0126:  BSF    03.6
0127:  MOVWF  0F
0128:  BSF    03.5
0129:  BSF    0C.7
012A:  BSF    0C.0
012B:  NOP
012C:  NOP
012D:  BCF    03.5
012E:  BCF    03.6
012F:  DECFSZ 24,F
0130:  GOTO   132
0131:  GOTO   135
0132:  BSF    03.5
0133:  BSF    03.6
0134:  GOTO   138
0135:  GOTO   157
0136:  BSF    03.5
0137:  BSF    03.6
0138:  BCF    03.5
0139:  RLF    0C,W
013A:  RLF    0E,W
013B:  ANDLW  7F
013C:  BCF    03.6
013D:  MOVWF  26
013E:  BSF    03.6
013F:  MOVF   0D,W
0140:  BCF    03.6
0141:  MOVWF  27
0142:  BSF    03.6
0143:  MOVF   0F,W
0144:  BCF    03.6
0145:  MOVWF  28
0146:  MOVF   26,W
0147:  MOVWF  2A
0148:  CALL   0DA
0149:  MOVF   27,W
014A:  BSF    03.6
014B:  MOVWF  0D
014C:  BCF    03.6
014D:  MOVF   28,W
014E:  BSF    03.6
014F:  MOVWF  0F
0150:  INCF   0D,F
0151:  BTFSC  03.2
0152:  INCF   0F,F
0153:  BCF    03.0
0154:  BCF    03.6
0155:  DECFSZ 24,F
0156:  GOTO   109
0157:  BTFSC  25.7
0158:  BSF    0B.7
0159:  RETURN
015A:  MOVF   2B,W
015B:  CLRF   78
015C:  SUBWF  2A,W
015D:  BTFSC  03.0
015E:  GOTO   162
015F:  MOVF   2A,W
0160:  MOVWF  77
0161:  GOTO   16E
0162:  CLRF   77
0163:  MOVLW  08
0164:  MOVWF  2C
0165:  RLF    2A,F
0166:  RLF    77,F
0167:  MOVF   2B,W
0168:  SUBWF  77,W
0169:  BTFSC  03.0
016A:  MOVWF  77
016B:  RLF    78,F
016C:  DECFSZ 2C,F
016D:  GOTO   165
016E:  RETURN
016F:  MOVLW  20
0170:  BTFSS  25.4
0171:  MOVLW  30
0172:  MOVWF  26
0173:  MOVF   24,W
0174:  MOVWF  77
0175:  BTFSS  24.7
0176:  GOTO   17F
0177:  COMF   77,F
0178:  INCF   77,F
0179:  MOVF   77,W
017A:  MOVWF  24
017B:  MOVLW  2D
017C:  MOVWF  26
017D:  BSF    25.7
017E:  BSF    25.0
017F:  MOVF   24,W
0180:  MOVWF  2A
0181:  MOVLW  64
0182:  MOVWF  2B
0183:  CALL   15A
0184:  MOVF   77,W
0185:  MOVWF  24
0186:  MOVLW  30
0187:  ADDWF  78,W
0188:  MOVWF  27
0189:  MOVF   24,W
018A:  MOVWF  2A
018B:  MOVLW  0A
018C:  MOVWF  2B
018D:  CALL   15A
018E:  MOVLW  30
018F:  ADDWF  77,W
0190:  MOVWF  29
0191:  MOVLW  30
0192:  ADDWF  78,W
0193:  MOVWF  28
0194:  MOVF   26,W
0195:  MOVWF  77
0196:  MOVLW  30
0197:  SUBWF  27,W
0198:  BTFSC  03.2
0199:  GOTO   19E
019A:  BSF    25.1
019B:  BTFSC  25.7
019C:  BSF    25.2
019D:  GOTO   1B2
019E:  MOVF   26,W
019F:  MOVWF  27
01A0:  MOVLW  20
01A1:  MOVWF  26
01A2:  MOVLW  30
01A3:  SUBWF  28,W
01A4:  BTFSC  03.2
01A5:  GOTO   1AA
01A6:  BSF    25.0
01A7:  BTFSC  25.7
01A8:  BSF    25.1
01A9:  GOTO   1B2
01AA:  BTFSS  03.2
01AB:  BSF    25.0
01AC:  BTFSS  03.2
01AD:  GOTO   1B2
01AE:  MOVF   27,W
01AF:  MOVWF  28
01B0:  MOVLW  20
01B1:  MOVWF  27
01B2:  BTFSC  25.2
01B3:  GOTO   1B9
01B4:  BTFSC  25.1
01B5:  GOTO   1BC
01B6:  BTFSC  25.0
01B7:  GOTO   1BF
01B8:  GOTO   1C2
01B9:  MOVF   26,W
01BA:  MOVWF  2A
01BB:  CALL   0DA
01BC:  MOVF   27,W
01BD:  MOVWF  2A
01BE:  CALL   0DA
01BF:  MOVF   28,W
01C0:  MOVWF  2A
01C1:  CALL   0DA
01C2:  MOVF   29,W
01C3:  MOVWF  2A
01C4:  CALL   0DA
01C5:  RETURN
....................  
.................... #list 
....................  
.................... #include <stdio.h>                  // C standart I/O baþlýk (header) dosyasý çaðrýlýyor  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
01D0:  BCF    03.5
01D1:  CLRF   20
01D2:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #use delay (clock=4000000)          // mikrodenetleyici saat frekansý ayarlanýyor 
*
002E:  MOVLW  2B
002F:  MOVWF  04
0030:  BCF    03.7
0031:  MOVF   00,W
0032:  BTFSC  03.2
0033:  GOTO   042
0034:  MOVLW  01
0035:  MOVWF  78
0036:  CLRF   77
0037:  DECFSZ 77,F
0038:  GOTO   037
0039:  DECFSZ 78,F
003A:  GOTO   036
003B:  MOVLW  4A
003C:  MOVWF  77
003D:  DECFSZ 77,F
003E:  GOTO   03D
003F:  GOTO   040
0040:  DECFSZ 00,F
0041:  GOTO   034
0042:  RETURN
.................... #fuses XT,NOWDT,NOPUT,NOPROTECT     // mikrodenetleyici konfigürasyonlarý ayarlanýyor  
.................... #use fast_io(b)                     // b portu manuel ayaralanacak 
.................... #use fast_io(a) 
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #define use_portb_lcd TRUE          // LCD B portuna baðlý 
.................... #include <lcd.c>                    // lcd.c dosyasý tanýtýlýyor 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
005B:  MOVLW  0F
005C:  BSF    03.5
005D:  ANDWF  06,W
005E:  IORLW  F0
005F:  MOVWF  06
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0060:  BCF    03.5
0061:  BSF    06.2
....................    delay_cycles(1); 
0062:  NOP
....................    lcd_output_enable(1); 
0063:  BSF    06.0
....................    delay_cycles(1); 
0064:  NOP
....................    high = lcd_read_nibble(); 
0065:  CALL   04F
0066:  MOVF   78,W
0067:  MOVWF  32
....................        
....................    lcd_output_enable(0); 
0068:  BCF    06.0
....................    delay_cycles(1); 
0069:  NOP
....................    lcd_output_enable(1); 
006A:  BSF    06.0
....................    delay_us(1); 
006B:  NOP
....................    low = lcd_read_nibble(); 
006C:  CALL   04F
006D:  MOVF   78,W
006E:  MOVWF  31
....................        
....................    lcd_output_enable(0); 
006F:  BCF    06.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0070:  MOVLW  0F
0071:  BSF    03.5
0072:  ANDWF  06,W
0073:  MOVWF  06
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0074:  BCF    03.5
0075:  SWAPF  32,W
0076:  MOVWF  77
0077:  MOVLW  F0
0078:  ANDWF  77,F
0079:  MOVF   77,W
007A:  IORWF  31,W
007B:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
004F:  MOVF   06,W
0050:  MOVWF  77
0051:  SWAPF  06,W
0052:  ANDLW  0F
0053:  MOVWF  78
....................   #endif 
0054:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0043:  SWAPF  32,W
0044:  ANDLW  F0
0045:  MOVWF  77
0046:  MOVLW  0F
0047:  ANDWF  06,W
0048:  IORWF  77,W
0049:  MOVWF  06
....................   #endif 
....................        
....................    delay_cycles(1); 
004A:  NOP
....................    lcd_output_enable(1); 
004B:  BSF    06.0
....................    delay_us(2); 
004C:  GOTO   04D
....................    lcd_output_enable(0); 
004D:  BCF    06.0
004E:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0055:  BSF    03.5
0056:  BCF    06.0
....................    lcd_rs_tris(); 
0057:  BCF    06.1
....................    lcd_rw_tris(); 
0058:  BCF    06.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0059:  BCF    03.5
005A:  BCF    06.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
007C:  MOVF   78,W
007D:  MOVWF  31
007E:  BTFSC  31.7
007F:  GOTO   05B
....................    lcd_output_rs(address); 
0080:  BTFSS  2F.0
0081:  BCF    06.1
0082:  BTFSC  2F.0
0083:  BSF    06.1
....................    delay_cycles(1); 
0084:  NOP
....................    lcd_output_rw(0); 
0085:  BCF    06.2
....................    delay_cycles(1); 
0086:  NOP
....................    lcd_output_enable(0); 
0087:  BCF    06.0
....................    lcd_send_nibble(n >> 4); 
0088:  SWAPF  30,W
0089:  MOVWF  31
008A:  MOVLW  0F
008B:  ANDWF  31,F
008C:  MOVF   31,W
008D:  MOVWF  32
008E:  CALL   043
....................    lcd_send_nibble(n & 0xf); 
008F:  MOVF   30,W
0090:  ANDLW  0F
0091:  MOVWF  31
0092:  MOVWF  32
0093:  CALL   043
0094:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0095:  MOVLW  0F
0096:  BSF    03.5
0097:  ANDWF  06,W
0098:  MOVWF  06
....................   #endif 
....................    lcd_enable_tris(); 
0099:  BCF    06.0
....................    lcd_rs_tris(); 
009A:  BCF    06.1
....................    lcd_rw_tris(); 
009B:  BCF    06.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
009C:  BCF    03.5
009D:  BCF    06.1
....................    lcd_output_rw(0); 
009E:  BCF    06.2
....................    lcd_output_enable(0); 
009F:  BCF    06.0
....................      
....................    delay_ms(15); 
00A0:  MOVLW  0F
00A1:  MOVWF  2B
00A2:  CALL   02E
....................    for(i=1;i<=3;++i) 
00A3:  MOVLW  01
00A4:  MOVWF  24
00A5:  MOVF   24,W
00A6:  SUBLW  03
00A7:  BTFSS  03.0
00A8:  GOTO   0B1
....................    { 
....................        lcd_send_nibble(3); 
00A9:  MOVLW  03
00AA:  MOVWF  32
00AB:  CALL   043
....................        delay_ms(5); 
00AC:  MOVLW  05
00AD:  MOVWF  2B
00AE:  CALL   02E
00AF:  INCF   24,F
00B0:  GOTO   0A5
....................    } 
....................     
....................    lcd_send_nibble(2); 
00B1:  MOVLW  02
00B2:  MOVWF  32
00B3:  CALL   043
....................    delay_ms(5); 
00B4:  MOVLW  05
00B5:  MOVWF  2B
00B6:  CALL   02E
....................    for(i=0;i<=3;++i) 
00B7:  CLRF   24
00B8:  MOVF   24,W
00B9:  SUBLW  03
00BA:  BTFSS  03.0
00BB:  GOTO   0C5
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00BC:  MOVF   24,W
00BD:  CALL   004
00BE:  MOVWF  25
00BF:  CLRF   2F
00C0:  MOVF   25,W
00C1:  MOVWF  30
00C2:  CALL   055
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00C3:  INCF   24,F
00C4:  GOTO   0B8
00C5:  BCF    0A.3
00C6:  BCF    0A.4
00C7:  GOTO   1DB (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
00C8:  DECFSZ 2C,W
00C9:  GOTO   0CB
00CA:  GOTO   0CE
....................       address=LCD_LINE_TWO; 
00CB:  MOVLW  40
00CC:  MOVWF  2D
00CD:  GOTO   0CF
....................    else 
....................       address=0; 
00CE:  CLRF   2D
....................       
....................    address+=x-1; 
00CF:  MOVLW  01
00D0:  SUBWF  2B,W
00D1:  ADDWF  2D,F
....................    lcd_send_byte(0,0x80|address); 
00D2:  MOVF   2D,W
00D3:  IORLW  80
00D4:  MOVWF  2E
00D5:  CLRF   2F
00D6:  MOVF   2E,W
00D7:  MOVWF  30
00D8:  CALL   055
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00D9:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
00DA:  MOVF   2A,W
00DB:  XORLW  07
00DC:  BTFSC  03.2
00DD:  GOTO   0E8
00DE:  XORLW  0B
00DF:  BTFSC  03.2
00E0:  GOTO   0ED
00E1:  XORLW  06
00E2:  BTFSC  03.2
00E3:  GOTO   0F5
00E4:  XORLW  02
00E5:  BTFSC  03.2
00E6:  GOTO   0FB
00E7:  GOTO   100
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
00E8:  MOVLW  01
00E9:  MOVWF  2B
00EA:  MOVWF  2C
00EB:  CALL   0C8
00EC:  GOTO   105
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
00ED:  CLRF   2F
00EE:  MOVLW  01
00EF:  MOVWF  30
00F0:  CALL   055
....................                      delay_ms(2); 
00F1:  MOVLW  02
00F2:  MOVWF  2B
00F3:  CALL   02E
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
00F4:  GOTO   105
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
00F5:  MOVLW  01
00F6:  MOVWF  2B
00F7:  MOVLW  02
00F8:  MOVWF  2C
00F9:  CALL   0C8
00FA:  GOTO   105
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
00FB:  CLRF   2F
00FC:  MOVLW  10
00FD:  MOVWF  30
00FE:  CALL   055
00FF:  GOTO   105
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0100:  MOVLW  01
0101:  MOVWF  2F
0102:  MOVF   2A,W
0103:  MOVWF  30
0104:  CALL   055
....................      #endif 
....................    } 
0105:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... int sayac=0;  
....................  
.................... int counter = 0; 
.................... void main() 
*
01C6:  CLRF   22
01C7:  CLRF   23
01C8:  BSF    03.5
01C9:  BSF    1F.0
01CA:  BSF    1F.1
01CB:  BSF    1F.2
01CC:  BCF    1F.3
01CD:  BCF    03.7
01CE:  MOVLW  1F
01CF:  ANDWF  03,F
.................... { 
....................    set_tris_b(0x00); 
*
01D3:  MOVLW  00
01D4:  BSF    03.5
01D5:  MOVWF  06
....................    set_tris_a(0xff); 
01D6:  MOVLW  FF
01D7:  MOVWF  05
....................    output_b(0x00); 
01D8:  BCF    03.5
01D9:  CLRF   06
....................     
....................    lcd_init(); 
01DA:  GOTO   095
....................    printf(lcd_putc,"\f Arac Sayisi %d", counter); 
01DB:  MOVLW  0C
01DC:  BSF    03.6
01DD:  MOVWF  0D
01DE:  MOVLW  00
01DF:  MOVWF  0F
01E0:  BCF    03.0
01E1:  MOVLW  0E
01E2:  BCF    03.6
01E3:  MOVWF  24
01E4:  CALL   106
01E5:  MOVF   23,W
01E6:  MOVWF  24
01E7:  MOVLW  18
01E8:  MOVWF  25
01E9:  CALL   16F
....................    while(TRUE) 
....................    { 
....................       if(input(pin_A0) == 0) 
01EA:  BTFSC  05.0
01EB:  GOTO   217
....................       { 
....................          while(input(pin_A0) == 0); 
01EC:  BTFSS  05.0
01ED:  GOTO   1EC
....................          delay_ms(70); 
01EE:  MOVLW  46
01EF:  MOVWF  2B
01F0:  CALL   02E
....................          counter++; 
01F1:  INCF   23,F
....................          if(counter == 21) 
01F2:  MOVF   23,W
01F3:  SUBLW  15
01F4:  BTFSS  03.2
01F5:  GOTO   208
....................          { 
....................             printf(lcd_putc,"\fArac giremez. %d", counter); 
01F6:  MOVLW  15
01F7:  BSF    03.6
01F8:  MOVWF  0D
01F9:  MOVLW  00
01FA:  MOVWF  0F
01FB:  BCF    03.0
01FC:  MOVLW  0F
01FD:  BCF    03.6
01FE:  MOVWF  24
01FF:  CALL   106
0200:  MOVF   23,W
0201:  MOVWF  24
0202:  MOVLW  18
0203:  MOVWF  25
0204:  CALL   16F
....................             counter = 20; 
0205:  MOVLW  14
0206:  MOVWF  23
....................          } 
0207:  GOTO   217
....................          else 
....................          printf(lcd_putc,"\fArac sayisi %d", counter); 
0208:  MOVLW  1E
0209:  BSF    03.6
020A:  MOVWF  0D
020B:  MOVLW  00
020C:  MOVWF  0F
020D:  BCF    03.0
020E:  MOVLW  0D
020F:  BCF    03.6
0210:  MOVWF  24
0211:  CALL   106
0212:  MOVF   23,W
0213:  MOVWF  24
0214:  MOVLW  18
0215:  MOVWF  25
0216:  CALL   16F
....................       } 
....................        
....................       if(input(pin_A1) == 0) 
0217:  BTFSC  05.1
0218:  GOTO   232
....................       { 
....................       delay_ms(70); 
0219:  MOVLW  46
021A:  MOVWF  2B
021B:  CALL   02E
....................       counter--; 
021C:  DECF   23,F
....................       if(counter == -1) 
021D:  MOVF   23,W
021E:  SUBLW  FF
021F:  BTFSS  03.2
0220:  GOTO   223
....................       counter = 0; 
0221:  CLRF   23
0222:  GOTO   232
....................       else 
....................       printf(lcd_putc,"\fArac Sayisi %d", counter); 
0223:  MOVLW  26
0224:  BSF    03.6
0225:  MOVWF  0D
0226:  MOVLW  00
0227:  MOVWF  0F
0228:  BCF    03.0
0229:  MOVLW  0D
022A:  BCF    03.6
022B:  MOVWF  24
022C:  CALL   106
022D:  MOVF   23,W
022E:  MOVWF  24
022F:  MOVLW  18
0230:  MOVWF  25
0231:  CALL   16F
....................       } 
0232:  GOTO   1EA
....................    } 
....................  
.................... } 
....................  
0233:  SLEEP

Configuration Fuses:
   Word  1: 3F79   XT NOWDT NOPUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
